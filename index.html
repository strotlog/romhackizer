<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Rotate a SM rando</title>
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://strotlog.github.io/randoxrotation/">
        <meta property="og:title" content="Rando&times;Rotation">
        <meta property="og:description" content="Copy the 100 item locations from a Super Metroid randomizer seed, into SM: Rotation">
        <!--<meta property="og:image" content="">-->

<script>

// utilities
function readUint16LE(bytearr, address) {
    return bytearr[address] + 256*bytearr[address+1]
}
function isAllFF(bytearr, address, length) {
    for (i = address; i < address+length; i++) {
        if (bytearr[i] !== 0xff) {
            return false
        }
    }
    return true
}
function applyPatch(modifications) {
    modifications.forEach((modification) => {
        for (i = 0; i < modification.bytes.length; i++) {
            loadedroms['rotation'].allbytes[modification.address + i] = modification.bytes[i]
        }
    })
}
function stringifyInHex(key, value) {
    if (typeof value === 'number') {
        return '0x' + value.toString(16)
    } else {
        return value
    }
}
// generated this list of 100 item locations in the rotation rom (the right side numbers) by hand 2022/01/05. 96 of them are the same as vanilla, and 2 pairs are swapped
rotationPlmAddressFromRando = {
0x78264: 0x78264,
0x78404: 0x78404,
0x78432: 0x78432,
0x7852c: 0x7852c,
0x78614: 0x78614,
0x786de: 0x786de,
0x7879e: 0x7879e,
0x787c2: 0x787c2,
0x787fa: 0x787fa,
0x78824: 0x78824,
0x78876: 0x78876,
0x7896e: 0x7896e,
0x7899c: 0x7899c,
0x78aca: 0x78aca,
0x78b24: 0x78b24,
0x78ba4: 0x78ba4,
0x78bac: 0x78bac,
0x78c36: 0x78c36,
0x78c3e: 0x78c3e,
0x78c82: 0x78c82,
0x78cca: 0x78cca,
0x79108: 0x79108,
0x79110: 0x79110,
0x79184: 0x79184,
0x7c2e9: 0x7c2e9,
0x7c337: 0x7c337,
0x7c365: 0x7c365,
0x7c36d: 0x7c36d,
0x7c47d: 0x7c47d,
0x7c559: 0x7c559,
0x7c5e3: 0x7c5e3,
0x7c6e5: 0x7c6e5,
0x7c755: 0x7c755,
0x7c7a7: 0x7c7a7,
0x781cc: 0x781cc,
0x781e8: 0x781e8,
0x781ee: 0x781ee,
0x781f4: 0x781f4,
0x78248: 0x78248,
0x783ee: 0x783ee,
0x78464: 0x78464,
0x7846a: 0x7846a,
0x78478: 0x78478,
0x78486: 0x78486,
0x784ac: 0x784ac,
0x784e4: 0x784e4,
0x78518: 0x78518,
0x7851e: 0x7851e,
0x78532: 0x78532,
0x78538: 0x78538,
0x78608: 0x78608,
0x7860e: 0x7860e,
0x7865c: 0x7865c,
0x78676: 0x78676,
0x7874c: 0x7874c,
0x78798: 0x78798,
0x787d0: 0x787d0,
0x78802: 0x78802,
0x78836: 0x78836,
0x7883c: 0x7883c,
0x788ca: 0x788ca,
0x7890e: 0x7890e,
0x78914: 0x78914,
0x789ec: 0x789ec,
0x78ae4: 0x78ae4,
0x78b46: 0x78b46,
0x78bc0: 0x78bc0,
0x78be6: 0x78be6,
0x78bec: 0x78bec,
0x78c04: 0x78c04,
0x78c14: 0x78c14,
0x78c2a: 0x78c2a,
0x78c44: 0x78c44,
0x78c52: 0x78c52,
0x78c66: 0x78c66,
0x78c74: 0x78c74,
0x78cbc: 0x78cbc,
0x78e6e: 0x78e6e,
0x78e74: 0x78e74,
0x78f30: 0x78f30,
0x78fca: 0x78fca,
0x78fd2: 0x78fd2,
0x790c0: 0x790c0,
0x79100: 0x79100,
0x7c265: 0x7c265,
0x7c2ef: 0x7c2ef,
0x7c319: 0x7c319,
0x7c357: 0x7c357,
0x7c437: 0x7c437,
0x7c43d: 0x7c43d,
0x7c483: 0x7c483,
0x7c4af: 0x7c4af,
0x7c4b5: 0x7c4b5,
0x7c533: 0x7c533,
0x7c5dd: 0x7c5dd,
0x7c5eb: 0x7c5eb,
0x7c5f1: 0x7c5f1,
0x7c603: 0x7c603,
0x7c609: 0x7c609,
0x7c74d: 0x7c74d
}
function patchmain() {
    let springballcount = 0
    // copy 100 plm's, 2 bytes each
    // modify the in-memory copy of rotation rom in-place to save a little space
    for (readRandoAddress in rotationPlmAddressFromRando) {
        readRandoAddress = Number(readRandoAddress) // the keys are strings. key written as 0xf in code will actually be string '15' until we convert it here! thanks javascript
        writeRotationAddress = rotationPlmAddressFromRando[readRandoAddress]
        loadedroms['rotation'].allbytes[writeRotationAddress] = loadedroms['rando'].allbytes[readRandoAddress]
        loadedroms['rotation'].allbytes[writeRotationAddress+1] = loadedroms['rando'].allbytes[readRandoAddress+1]

        // console.log(writeRotationAddress.toString(16) + ': wrote ' + loadedroms['rando'].allbytes[readRandoAddress].toString(16) + ' ' + loadedroms['rando'].allbytes[readRandoAddress+1].toString(16) + (readRandoAddress!==writeRotationAddress ? ' - read from ' + readRandoAddress.toString(16) : ''))

        // check for race mode
        itemcopied = loadedroms['rando'].allbytes[readRandoAddress] + loadedroms['rando'].allbytes[readRandoAddress+1]*256 // convert plm from little endian
        if (itemcopied === 0xef03 || itemcopied === 0xef57 || itemcopied === 0xefab) {
            springballcount++
        }
        if (springballcount > 5) {
            console.log('Error: Cannot read items from a Race-Mode protected rando ROM!!')
            return -1
        }
    }

    // items are done. now do a select few code patches that make things suck less!

    // code patch (2): fix morph pickup bug
    // per https://github.com/theonlydude/RandomMetroidSolver/blob/master/patches/common/src/vanilla_bugfixes.asm "fix morph ball in hidden chozo PLM",
    // and confirmed at http://patrickjohnston.org/bank/84#fE3EF ,
    // there is a vanilla bug in normally unused code.  picking up a hidden morph ball or a chozo morph ball will result in you getting spring ball instead (lol).
    // this vanilla bug is not fixed in sm rotation (cause why would it be) so let's fix it here!
    loadedroms['rotation'].allbytes[0x268CE] = 4 // moprh in chozo orb. 4=morph item-having bit. was 2=spring
    loadedroms['rotation'].allbytes[0x26E02] = 4 // moprh in hidden aka shot block. 4=morph item-having bit. was 2=spring

    // code patch (3): awaken zebes when player transitions from morph ball room to construction zone (otherwise, if you don't get ammo among the first 2 items, you are softlocked). MANY, MANY more softlocks are NOT prevented
    ret = awakeningPatch()
    if (ret != 0) {
        return ret
    }

    // code patch (4): balanced suits, cause varia being useless is not very fun!
    loadedroms['rotation'].allbytes[0x6e37d] = 0x01 // remove gravity's heat protection
    loadedroms['rotation'].allbytes[0x869dd] = 0x01 // replace the code where environmental damage calculation looks for gravity suit, with varia suit instead (in function $90:E9CE). gravity does nothing for enviro now

    return 0
}

function awakeningPatch() {
    // all 3 real doors should be going to the rooms we think they are, and should have no door asm. just to be sure we're overwriting the right thing! this also makes us resilient to door repointing, and able to bail if rooms have been repointed
    // morph ball room's header (0x79e9f) in bank $8f:
    //     .(doors out arr pointer @ offset +9)
    // doors out arr in bank $8f:
    //     door 1 pointer - door to green hill zone (0x79e52) (points to door header for this door - door bank $83 is implied for door headers)
    //     door 2 pointer - door to construction zone (0x79f11)
    //     door 3 pointer - door to top of morph ball elevator room (0x797b5)
    //     fake door 4 pointer 88FC - means end of list - dereference and find offset 0 is 0000
    // door header in bank $83:
    //     .(dest room pointer, a room header @ offset 0)
    //     .(door asm pointer @ offset +0xa - bank $8f is implied for door asm code)
    requireddestinations = [{smileid: 0x79e52, roomname: 'Green Hill Zone'},
                            {smileid: 0x79f11, roomname: 'Construction Zone'},
                            {smileid: 0x797b5, roomname: 'Top of Morph Ball Elevator Room'},
                           ]
    destinationToModify = requireddestinations[1] // Construction Zone
    
    // read all 3 doors
    doorliststart = readUint16LE(loadedroms['rotation'].allbytes, 0x79e9f + 9)
    doorliststart |= 0x70000 // prepare to read again from bank $8f
    doors = [doorliststart, doorliststart+2, doorliststart+4].map(
    
        (doorlistentry) => readUint16LE(loadedroms['rotation'].allbytes, doorlistentry) | 0x10000 /* prepare to read from bank $83 */).map(
    
        (doorheader) => ({
            dest:    readUint16LE(loadedroms['rotation'].allbytes, doorheader),
            doorasm: readUint16LE(loadedroms['rotation'].allbytes, doorheader+0xa),
            thisDoorHeaderLocationInRom: doorheader,
        }))
    for (i = 0; i < requireddestinations.length; i++) {
        if (!(doors.map((door) => door.dest)).includes(requireddestinations[i].smileid & 0xffff)) {
            console.log('Error: Bailing, cannot confidently apply zebes awakening patch because ' + requireddestinations[i].roomname + ' not found in morph ball room\'s adjacent rooms in rotation rom. Doors found: ' + JSON.stringify(doors, stringifyInHex))
            return -1
        }
    }
    for (i = 0; i < doors.length; i++) {
        if (doors[i].doorasm != 0) {
            console.log('Error: At least one door in morph ball room in rotation rom, has door ASM already, cannot confidently apply zebes awakening patch. Doors found: ' + JSON.stringify(doors, stringifyInHex))
            return -1
        }
        if (doors[i].dest == (destinationToModify.smileid & 0xffff)) {
            doorToModifyIndex = i
        }
    }
    doorAsmRomAddressToModify = doors[doorToModifyIndex].thisDoorHeaderLocationInRom + 0xa
    
    // the instructions for this hack use free space at $8F:FF00 in varia rando (must be in bank $8f), we'll use the same (checking that it's not used first)
    // part 1: when entering construction zone from morph ball room ...
    // part 2: ... set zebes awake event bit. (does not affect the currently loaded/loading room, but effective thereafter)
    // part 3: when checking the state of pit room or top of morph elevator room, read the zebes awake flag directly
    //           (part 3 implementation choice: normally we'd just change the function pointer for the state-checking function, to point to the function that checks for a given event. done and done. but wait, that function requires 1 byte of space for a parameter (the "given event"), right after the function pointer, and the vanilla morph+missile checking function requires no parameter. so inserting that 1 byte for a parameter would require repointing a ton of stuff! so we overwrite the morph+missile state-checking function's contents instead.)
    zebesAwakeningPatch = [{address: doorAsmRomAddressToModify, bytes: [0xff, 0x00].reverse()},
                           {address: 0x7ff00, bytes: [0xaf /* load  */, [0x7e, 0xd8, 0x20].reverse(),
                                                      0x9 /* or */, [0x0, 0x1].reverse(),
                                                      0x8f /* store */, [0x7e, 0xd8, 0x20].reverse(),
                                                      /* TODO: should probably move this next part cause it's gonna look weird when you see changing door colors */
                                                      0xaf /* load  */, [0x7e, 0xd8, 0xb6].reverse(),
                                                      0x9, /* or */, [0x0, 0x4].reverse(),
                                                      0x8f /* store */, [0x7e, 0xd8, 0xb6].reverse(),
                                                      0x60 /* return */,
                                                      ].flat()},
                           {address: 0x7e652, bytes: [0xaf /* load  */, [0x7e, 0xd8, 0x20].reverse(),
                                                      0x89 /* bit test A with constant */, [0x00, 0x01].reverse(),
                                                      0xd0 /* bne: branch if (test was) non-zero */, 0x3,
                                                      // fall back to default state - room is dead
                                                      0xe8, /* increment X */
                                                      0xe8, /* increment X - fully passed over the pointer to 2nd (room alive) room state header, register X now pointing to next function pointer (E5E6: default state handler) */
                                                      0x60, /* return */
                                                      // specify state header "room is alive"!
                                                      0xbd /* load A=*(X+0) */, 0x00, 0x00,
                                                      0xaa, /* tax (X=A) */
                                                      0x4c, [0xe5, 0xe6].reverse()
                                                      ].flat()},
                           ]
    if (!(isAllFF(loadedroms['rotation'].allbytes, zebesAwakeningPatch[1].address, zebesAwakeningPatch[1].bytes.length))) {
        console.log('Error: Code already exists in rotation rom at + 0x' + zebesAwakeningPatch[1].address.toString(16) + ', cannot write zebes awakening patch!')
        return -1
    }
    if (zebesAwakeningPatch[2].bytes.length > 19) {
        console.log('Implementation error: patching ROM function $8F:E652 has space for only 19 bytes, but the one in this javascript code is ' + zebesAwakeningPatch[2].bytes.length + ' bytes long which does not fit!')
        return -1
    }
    
    applyPatch(zebesAwakeningPatch)
    return 0
}

loadedroms = {}

function addRomFiles(purpose, filesarr) {
    if (filesarr.length === 0) {
        return
    }
    if (filesarr.length > 1) {
        console.log('Received ' + filesarr.length + ' files at once, ignoring (expected 1)')
        return
    }
    let fr = new FileReader()
    // ".onload" is basically the ".then" of readAsArrayBuffer() which we're about to call
    fr.onload = function(event) {
        loadedroms[purpose] = {
            filename: filesarr[0].name,
            allbytes: new Uint8Array(event.target.result),
        }
        updateState()
    }
    fr.readAsArrayBuffer(filesarr[0])
}

function updateState() {
    if ('rotation' in loadedroms) {
        document.getElementById('spanIdRotationRomFilename').textContent = loadedroms['rotation'].filename
    }
    if ('rando' in loadedroms) {
        document.getElementById('spanIdRandoRomFilename').textContent = loadedroms['rando'].filename
    }
    if ('rotation' in loadedroms && 'rando' in loadedroms) {
        if (loadedroms['rotation'].allbytes.length < 2*1024*1024) {
            console.log('Rotation ROM provided is only ' + loadedroms['rotation'].allbytes.length + ' bytes, expected over ' + 3*1024*1024)
            return
        }
        if (loadedroms['rando'].allbytes.length < 2*1024*1024) {
            console.log('Rando ROM provided is only ' + loadedroms['rando'].allbytes.length + ' bytes, expected ' + 3*1024*1024 + ' or more')
            return
        }
        ret = patchmain()
        if (ret != 0) { return }

        let blob = new Blob([loadedroms['rotation'].allbytes], {type: 'application/octet-stream'})
        document.getElementById('aIdDownloadLink').href = URL.createObjectURL(blob)
        document.getElementById('aIdDownloadLink').download = 'SM Rotation with items copied from ' + loadedroms['rando'].filename
        document.getElementById('aIdDownloadLink').textContent = 'Download Modified SM: Rotation'
    }
}

</script>
    </head>

<body ondrop="event.preventDefault()"
      ondragover="event.preventDefault()">
    <p>Rando&times;Rotation: Welcome to a very basic Web tool that shuffles the items in <strong><a href="https://metroidconstruction.com/hack.php?id=350">Super Metroid: Rotation</a></strong> (Beta 11).</p>
    <p>This is not exactly a randomizer. Instead, it copies the locations of all the items from a <strong><a href="https://varia.run/">VARIA Randomizer</a></strong> ROM seed that you provide. (VARIA itself may include a rotation randomizer soon.)</p>
    <p>This:</p>
    <ul>
        <li>Applies only very <dfn title="1. TBD, 2. vanilla bug patch(es), 3. zebes always awakens & construction zone blue door, 4. balanced suits" style="font-style: normal; text-decoration: underline; text-decoration-style: dotted">minimal</dfn> code patches from the randomizer (the list may grow later). It is exactly like SM: Rotation except the items are moved. Be careful and save!</li>
        <li><strong>Does not ensure the seed is completable.</strong></li>
        <li>Will not show errors plainly yet - check your browser's console if a download link doesn't appear.</li>
        <li>Will not upload or store anything - it's all in your browser. (This means links generated are very temporary and local to this tab.)</li>
    </ul>
    <p>by strotlog 2022</p>
    <div id='divIdRandoRomArea' style='border: 1px; border-style: dotted' ondrop="event.preventDefault(); addRomFiles('rando', event.dataTransfer.files)">
        <h3>Rando ROM</h3>
        <input type='file' id='inputIdRandoRom' style='display:none' onchange="addRomFiles('rando', this.files)"/>
        <input type='button' id='inputIdRandoRomButton' value='Browse' onclick="document.getElementById('inputIdRandoRom').click()"/>
        <span id='spanIdRandoRomFilename'>(No file)</span>
    </div>
    <div id='divIdRotationRomArea' style='border: 1px; border-style: dotted' ondrop="event.preventDefault(); addRomFiles('rotation', event.dataTransfer.files)">
        <h3>Vanilla Rotation ROM</h3>
        <input type='file' id='inputIdRotationRom' style='display:none' onchange="addRomFiles('rotation', this.files)"/>
        <input type='button' id='inputIdRotationRomButton' value='Browse' onclick="document.getElementById('inputIdRotationRom').click()"/>
        <span id='spanIdRotationRomFilename'>(No file)</span>
    </div>
    <div>
        <h3>
            <a href='#' download='' id='aIdDownloadLink'></a>
        </h3>
    </div>
</body>
</html>
