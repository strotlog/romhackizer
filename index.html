<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Rotate a SM rando</title>
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://strotlog.github.io/randoxrotation/">
        <meta property="og:title" content="Rando&times;Rotation">
        <meta property="og:description" content="Copy the 100 item locations from a Super Metroid randomizer seed, into SM: Rotation">
        <!--<meta property="og:image" content="">-->

<script>

// utilities
function stringifyInHex(key, value) {
    if (typeof value === 'number') {
        return '0x' + value.toString(16)
    } else {
        return value
    }
}
function readUint16LE(bytearr, address) {
    return bytearr[address] + 256*bytearr[address+1]
}
function applyPatch(modifications) {
    modifications.forEach((modification) => {
        for (i = 0; i < modification.bytes.length; i++) {
            loadedroms['rotation'].allbytes[modification.address + i] = modification.bytes[i]
        }
    })
}
function checkForPatch(modifications) {
    rets = modifications.map((modification) => {
        for (i = 0; i < modification.bytes.length; i++) {
            if (loadedroms['rotation'].allbytes[modification.address + i] !== modification.bytes[i]) {
                return false
            }
        }
        return true // this modification found
    })
    if (rets.includes(false)) {
        return false
    }
    return true // all modifications found
}
function checkForFreespaceConflict(modifications) {
    rets = modifications.map((modification) => {
        if (modification.type !== 'freespace') {
            return false
        }
        for (i = modification.address; i < modification.bytes.length; i++) {
            if (loadedroms['rotation'].allbytes[i] !== 0xff) {
                // current copy of the rotation rom has code where freespace was expected
                if (checkForPatch([modification])) {
                    // no problem, the rotation rom already has exactly this patch
                    // (as is the case when we rpocess multiple seeds in one session
                    return false
                } else {
                    // not 0xff and not the exact same patch => a conflict
                    console.log('patch beginning at 0x' + modification.address.toString(16) + ' length 0n' + modification.allbytes.length + ' which is intended for free space, conflicts with data found in the rotation rom')
                    return true
                }
            }
        }
        return false
    })
    if (rets.includes(true)) {
        return true
    }
    return false // all modifications had no conflict
}
function checkForOverlappingPatches(modifications) {
    // turn each patch into 2 markers: one for where it begins, one for where it ends. then sort all the markers together and check for double-begins
    ordered = modifications.map((modification) => [{address: modification.address, type: 'begin' },
                                                   {address: modification.address + modification.bytes.length, type: 'end'}]
                                ).flat().sort((a, b) => {
                                    if (a.address < b.address) { return -1 }
                                    if (a.address > b.address) { return 1 }
                                    // consider 'end' as less than 'begin', because if one patch ends where another begins that's ok ('end' points to the first byte not modified by a given patch)
                                    if (a.type === 'end'   && b.type === 'begin') { return -1 }
                                    if (a.type === 'begin' && b.type === 'end'  ) { return 1 }
                                    return 0
                                })
    begunpatches = 0
    for (i = 0; i < ordered.length; i++) {
        if (ordered[i].type === 'begin') {
            begunpatches++
        } else {
            begunpatches--
        }
        if (begunpatches > 1) {
            console.log('patch beginning at 0x' + ordered[i].address.toString(16) + ' overlaps with an earlier patch! all patches examined: ' + JSON.stringify(modifications, stringifyInHex))
            return true // overlap!
        }
    }
    return false
}
function assembleUnambiguousInstructions(modifications) {
    ret = modifications.map(function (modification) {
        modification.bytes = modification.bytes.map(function (byteOrOpcode) {
            if (typeof byteOrOpcode !== 'string') {
                return byteOrOpcode
            }
            if (byteOrOpcode.toUpperCase() in unambiguousInstructionMapping) {
                return unambiguousInstructionMapping[byteOrOpcode.toUpperCase()]
            }
            console.log('patch beginning at 0x' + modification.address.toString(16) + ' contains the opcode \'' + byteOrOpcode + '\', which does not exist OR is ambiguous (context-dependent opcodes like LDA are not supported yet)')
            return 'error'
        });
        if (modification.bytes.includes('error')) {
            return 'error'
        }
        return modification
    });
    if (ret.includes('error')) {
        return []
    }
    return ret
}
unambiguousInstructionMapping = {
'INY': 0xC8, 'INX': 0xE8, 'DEY': 0x88, 'DEX': 0xCA, 'BPL': 0x10, 'BMI': 0x30, 'BVC': 0x50, 'BVS': 0x70,
'BRA': 0x80, 'BRL': 0x82, 'BCC': 0x90, 'BCS': 0xB0, 'BNE': 0xD0, 'BEQ': 0xF0, 'JSL': 0x22, 'RTS': 0x60,
'RTL': 0x6B, 'CLC': 0x18, 'SEC': 0x38, 'CLI': 0x58, 'SEI': 0x78, 'CLV': 0xB8, 'CLD': 0xD8, 'SED': 0xF8,
'TCS': 0x1B, 'TSC': 0x3B, 'TCD': 0x5B, 'TDC': 0x7B, 'TXA': 0x8A, 'TYA': 0x98, 'TXS': 0x9A, 'TXY': 0x9B,
'TAY': 0xA8, 'TAX': 0xAA, 'TSX': 0xBA, 'TYX': 0xBB, 'MVP': 0x44, 'MVN': 0x54, 'PER': 0x62, 'PEI': 0xD4,
'PEA': 0xF4, 'PHP': 0x08, 'PHD': 0x0B, 'PHA': 0x48, 'PHK': 0x4B, 'PHY': 0x5A, 'PHB': 0x8B, 'PHX': 0xDA,
'PLP': 0x28, 'PLD': 0x2B, 'PLA': 0x68, 'PLY': 0x7A, 'PLB': 0xAB, 'PLX': 0xFA, 'NOP': 0xEA, 'REP': 0xC2,
'SEP': 0xE2, 'XBA': 0xEB, 'XCE': 0xFB, 'BRK': 0x00, 'COP': 0x02, 'RTI': 0x40, 'WAI': 0xCB, 'STP': 0xDB,
}

// generated this list of 100 item locations in the rotation rom (the right side numbers) by hand 2022/01/05. 96 of them are the same as vanilla, and 2 pairs are swapped
rotationPlmAddressFromRando = {
0x78264: 0x78264,
0x78404: 0x78404,
0x78432: 0x78432,
0x7852c: 0x7852c,
0x78614: 0x78614,
0x786de: 0x786de,
0x7879e: 0x7879e,
0x787c2: 0x787c2,
0x787fa: 0x787fa,
0x78824: 0x78824,
0x78876: 0x78876,
0x7896e: 0x7896e,
0x7899c: 0x7899c,
0x78aca: 0x78aca,
0x78b24: 0x78b24,
0x78ba4: 0x78ba4,
0x78bac: 0x78bac,
0x78c36: 0x78c36,
0x78c3e: 0x78c3e,
0x78c82: 0x78c82,
0x78cca: 0x78cca,
0x79108: 0x79108,
0x79110: 0x79110,
0x79184: 0x79184,
0x7c2e9: 0x7c2e9,
0x7c337: 0x7c337,
0x7c365: 0x7c365,
0x7c36d: 0x7c36d,
0x7c47d: 0x7c47d,
0x7c559: 0x7c559,
0x7c5e3: 0x7c5e3,
0x7c6e5: 0x7c6e5,
0x7c755: 0x7c755,
0x7c7a7: 0x7c7a7,
0x781cc: 0x781cc,
0x781e8: 0x781e8,
0x781ee: 0x781ee,
0x781f4: 0x781f4,
0x78248: 0x78248,
0x783ee: 0x783ee,
0x78464: 0x78464,
0x7846a: 0x7846a,
0x78478: 0x78478,
0x78486: 0x78486,
0x784ac: 0x784ac,
0x784e4: 0x784e4,
0x78518: 0x78518,
0x7851e: 0x7851e,
0x78532: 0x78532,
0x78538: 0x78538,
0x78608: 0x78608,
0x7860e: 0x7860e,
0x7865c: 0x7865c,
0x78676: 0x78676,
0x7874c: 0x7874c,
0x78798: 0x78798,
0x787d0: 0x787d0,
0x78802: 0x78802,
0x78836: 0x78836,
0x7883c: 0x7883c,
0x788ca: 0x788ca,
0x7890e: 0x7890e,
0x78914: 0x78914,
0x789ec: 0x789ec,
0x78ae4: 0x78ae4,
0x78b46: 0x78b46,
0x78bc0: 0x78bc0,
0x78be6: 0x78be6,
0x78bec: 0x78bec,
0x78c04: 0x78c04,
0x78c14: 0x78c14,
0x78c2a: 0x78c2a,
0x78c44: 0x78c44,
0x78c52: 0x78c52,
0x78c66: 0x78c66,
0x78c74: 0x78c74,
0x78cbc: 0x78cbc,
0x78e6e: 0x78e6e,
0x78e74: 0x78e74,
0x78f30: 0x78f30,
0x78fca: 0x78fca,
0x78fd2: 0x78fd2,
0x790c0: 0x790c0,
0x79100: 0x79100,
0x7c265: 0x7c265,
0x7c2ef: 0x7c2ef,
0x7c319: 0x7c319,
0x7c357: 0x7c357,
0x7c437: 0x7c437,
0x7c43d: 0x7c43d,
0x7c483: 0x7c483,
0x7c4af: 0x7c4af,
0x7c4b5: 0x7c4b5,
0x7c533: 0x7c533,
0x7c5dd: 0x7c5dd,
0x7c5eb: 0x7c5eb,
0x7c5f1: 0x7c5f1,
0x7c603: 0x7c603,
0x7c609: 0x7c609,
0x7c74d: 0x7c74d
}
function patchmain() {
    let springballcount = 0
    // copy 100 plm's, 2 bytes each
    // modify the in-memory copy of rotation rom in-place to save a little space
    for (readRandoAddress in rotationPlmAddressFromRando) {
        readRandoAddress = Number(readRandoAddress) // the keys are strings. key written as 0xf in code will actually be string '15' until we convert it here! thanks javascript
        writeRotationAddress = rotationPlmAddressFromRando[readRandoAddress]
        loadedroms['rotation'].allbytes[writeRotationAddress] = loadedroms['rando'].allbytes[readRandoAddress]
        loadedroms['rotation'].allbytes[writeRotationAddress+1] = loadedroms['rando'].allbytes[readRandoAddress+1]

        // console.log(writeRotationAddress.toString(16) + ': wrote ' + loadedroms['rando'].allbytes[readRandoAddress].toString(16) + ' ' + loadedroms['rando'].allbytes[readRandoAddress+1].toString(16) + (readRandoAddress!==writeRotationAddress ? ' - read from ' + readRandoAddress.toString(16) : ''))

        itemcopied = loadedroms['rando'].allbytes[readRandoAddress] + loadedroms['rando'].allbytes[readRandoAddress+1]*256 // convert plm from little endian
        // check for 'nothing item plm' from VARIA rando - see https://github.com/theonlydude/RandomMetroidSolver/blob/master/patches/common/src/nothing_item_plm.asm
        if (itemcopied === 0xbae9 || itemcopied === 0xbaed) {
            // DO OVER - because the 'nothing item plm' does not exist in sm rotation, we have to use plm id 0xb62f "Don't make PLM" instead. equivalent except no shot blocks
            loadedroms['rotation'].allbytes[writeRotationAddress] = 0x2f
            loadedroms['rotation'].allbytes[writeRotationAddress+1] = 0xb6
        }
        // check for race mode
        if (itemcopied === 0xef03 || itemcopied === 0xef57 || itemcopied === 0xefab) {
            springballcount++
        }
        if (springballcount > 5) {
            console.log('Error: Cannot read items from a Race-Mode protected rando ROM!!')
            return -1
        }
    }

    // items are done. now do a select few code patches that make things suck less!


    // code patch (2): fix morph pickup bug
    // per https://github.com/theonlydude/RandomMetroidSolver/blob/master/patches/common/src/vanilla_bugfixes.asm "fix morph ball in hidden chozo PLM",
    // and confirmed at http://patrickjohnston.org/bank/84#fE3EF ,
    // there is a vanilla bug in normally unused code.  picking up a hidden morph ball or a chozo morph ball will result in you getting spring ball instead (lol).
    // this vanilla bug is not fixed in sm rotation (cause why would it be) so let's fix it here!
    loadedroms['rotation'].allbytes[0x268CE] = 4 // moprh in chozo orb. 4=morph item-having bit. was 2=spring
    loadedroms['rotation'].allbytes[0x26E02] = 4 // moprh in hidden aka shot block. 4=morph item-having bit. was 2=spring

    // code patch (3): awaken zebes when player transitions from morph ball room to construction zone (otherwise, if you don't get ammo among the first 2 items, you are softlocked). MANY, MANY more softlocks are NOT prevented
    ret = awakeningPatch()
    if (ret != 0) {
        return ret
    }

    // code patch (4): balanced suits, cause varia being useless is not very fun!
    loadedroms['rotation'].allbytes[0x6e37d] = 0x01 // remove gravity's heat protection
    loadedroms['rotation'].allbytes[0x869dd] = 0x01 // replace the code where environmental damage calculation looks for gravity suit, with varia suit instead (in function $90:E9CE). gravity does nothing for enviro now

    allOtherPatches = []

    // code patch (5): fix rotation escape climb's PLM coordinates issues by strotlog
    allOtherPatches = allOtherPatches.concat(fixEscapeClimb)

    // code patch (6): max ammo display by strotlog
    allOtherPatches = allOtherPatches.concat(maxAmmoDisplay)

    // code patch (7): suit pickup softlock prevention by strotlog
    allOtherPatches = allOtherPatches.concat(suitPickupsNowPreserveSamusLocation)

    if (checkForOverlappingPatches(allOtherPatches)) {
        return -1
    }
    if (checkForFreespaceConflict(allOtherPatches)) {
        return -1
    }
    allOtherPatches = assembleUnambiguousInstructions(allOtherPatches)
    if (allOtherPatches.length === 0) {
        return -1
    }
    applyPatch(allOtherPatches)

    return 0
}

// SM rotation bug: rando softlock possible because bomb wall does not auto-break in climb room (room $796BA) during escape.
// let's modify what SM rotation didn't modify:
//   the setup ASM for this roomstate
//     - lives at $8f:91a9
//     - contains tile x and y coordinates for where, upon entering room, to spawn a PLM with particular coordinates
//       (who knows why deerforce made the PLM spawn using ASM. cause i assume it's equivalent to putting the PLM in the usual spot, the room state header's PLM set)
//   the "pre-instruction" ASM for the code-spawned PLM
//     - lives at $84:b927
//     - does damage at the PLM's location only when samus is below and to the right of a pixel position that's hard-coded into the function
//   the initialization AI ASM of the fake enemy projectile that gets spawned by the above PLM
//     - lives in $86:b49d
//     - hard-codes a position of a fake enemy projectile that visually pretends to cause the explosion (it's not necessary to fix this for functioning)
fixEscapeClimb = [
    // setup ASM hard-coded values modification:
    {address: 0x791ad, type: 'overwrite',
     bytes: [0x07, 0x10]}, // new (x, y) tile coordinate location of PLM. keep it in the bomb wall just like vanilla sm. moved 1px to the (new left) cause the whole thing doesn't blow up anymore due to who knows what
    // pre-instruction ASM hard-coded values modification:
    {address: 0x23928, type: 'overwrite',
     bytes: [0x00, 0x00].reverse()}, // new X-pixel location of the trigger (X target=0 will always be satisfied)
    {address: 0x2392d, type: 'overwrite',
     bytes: [0x00, 0xe0].reverse()}, // new Y-pixel location of the trigger: 0x00d0. trigger on samus's center breaking a plane 2 tile heights above the top of the wall
    // projectile initialization AI ASM hard-coded values modification:
    {address: 0x3349e, type: 'overwrite',
     bytes: [0x00, 0x80].reverse()}, // new X-pixel location of the visual explosion graphic: 0x0080
    {address: 0x334a7, type: 'overwrite',
     bytes: [0x01, 0x00].reverse()}, // new Y-pixel location of the visual explosion graphic: 0x0100. pixel (0x0080, 0x0100) is tile (x=0x08, y=0x10) which puts the graphic right in the middle of the top row of the barrier in rotation, at least after screen shake
]

// questionable solution because https://wiki.nesdev.org/w/index.php?title=Overscan
maxAmmoDisplay = [
    {address: 0x01caa, type: 'overwrite',
    bytes: [
            // modify function "$80:9B44: Handle HUD tilemap (HUD routine when game is paused/running)" @ $80:9CAA
            'bra', 8, // skip the next 8 bytes, so that we can use them as jsl->jsr launchpads: very tiny functions which will let us call bank $80 local functions from within other code in other banks
            0x20 /* jsr */, [0x9d, 0x78].reverse(), // thus we can use "jsl $80:9CAC" to be able to call $80:9D78: "Draw three HUD digits"
            'rtl',
            0x20 /* jsr */, [0x9d, 0x98].reverse(), // thus we can use "jsl $80:9CB0" to be able to call $80:9D98: "Draw two HUD digits"
            'rtl',

            'jsl', [0x80, 0xd4, 0x00].reverse(), // long in case i need to repoint the main code (below) to live in a different bank than $80. (also why we have launchpads)
            'nop', // to avoid overwriting only half an instruction
            ].flat()},
    {address: 0x05400, type: 'freespace',
     bytes: [
             // new code at $80:d400:
             //   this is a wrapper function to ensure we always run the vanilla code without resorting to a jmp
             0x20 /* jsr */, [0xd4, 0x18].reverse(), // call $80:d418
             // vanilla code we overwrote
             0xAE, 0x30, 0x03, // LDX $0330
             0xA9, 0xC0, 0x00, // LDA #$00C0
             0x95, 0xD0,       // STA $D0,x
             0xE8,             // INX
             0xE8,             // INX
             0xA9, 0x08, 0xC6, // LDA #$C608
             0x95, 0xD0,       // STA $D0,x
             'rtl', // return
             ].flat()},
    {address: 0x05418, type: 'freespace',
     bytes: [
             // new code at $80:d418:
             // essentially, (1) entry of equipment screen? -> write max ammo on screen,
             //              (2) leaving the equipment screen (back to map screen or unpause) -> remove max ammo from screen
             // start by seeing exactly what state we are in.
             // this could have been simplified by simply hooking (1)+(2a)+(2b) mentioned above, but we'll just implement with a bunch of if's here,
             // in order to keep us flexible for displaying on a different screen in a future implementation.
             0xad /* lda load */, [0x09, 0x98].reverse(), // load $0998 : game state
             0x29 /* and imm */, [0x00, 0xff].reverse(), // low byte only
             0xc9 /* cmp */, [0x00, 0x08].reverse(), // $0998 (game state) == 0x8 (main gameplay)?
             'bne', 1, // skip rts if not equal
             'rts', // return first thing if we're in main gameplay!

             0xc9 /* cmp */, [0x00, 0x11].reverse(), // $0998 (game state) == 0x11 (exiting pause)?
             'bne', 4, // skip jsr:rts if not equal
             0x20 /* jsr */, [0xd5, 0x28].reverse(), // 0x11 (exiting pause) => call $80:d528 (check if we need to do cleanup and do so)
             'rts', // return after calling the cleanup check

             0xc9 /* cmp */, [0x00, 0x12].reverse(), // $0998 (game state) == 0x12 (exiting pause v2)?
             'bne', 4, // skip jsr:rts if not equal
             0x20 /* jsr */, [0xd5, 0x28].reverse(), // 0x12 (exiting pause v2) => call $80:d528 (check if we need to do cleanup and do so)
             'rts', // return after calling the cleanup check

             0xc9 /* cmp */, [0x00, 0x0f].reverse(), // $0998 (game state) == 0xf (paused)?
             'beq' /* branch if equal */, 1, // skip rts if yes (equal)
             'rts', // return if not paused
             // yes we are paused:

             0xad /* lda load */, [0x07, 0x27].reverse(), // load $0727 : pause screen state aka pause index.
             0xc9 /* cmp */, [0x00, 0x06].reverse(), // $0727 (pause screen state) == 6 (loading the map screen after having shown equipment screen)? we probably only get called once in this state this which is cool)
             'bne', 4, // skip jsr:rts if not equal
             0x20 /* jsr */, [0xd5, 0x28].reverse(), // 6 (loading the map screen after having shown equipment screen) => call $80:d528 (check if we need to do cleanup and do so)
             'rts', // return after calling the cleanup check

             0xc9 /* cmp */, [0x00, 0x03].reverse(), // $0727 (pause screen state) == 3 (loading the equipment screen)? we probably only get called once in this state this which is cool)
             'beq', 1, // skip rts if equal
             'rts', // return if not deep in a transition between pause screens

             // we are paused and on the equipment screen (pause screen state 1, 4, or 5)! do the thing! (draw max ammos - we'll do it kind of the way $80:9B44 draws current ammos)

             // for the new max ammo count digits: we need nine (9) 8px by 8px tiles (out of a full row of 32) in an abbreviated row above the ammo displays.
             // this spot is above where the game normally displays anything! so that part'll be a bit hacky.
             // we need a spot in RAM (WRAM) to set up the initial tile data (2 bytes per tile = 18 bytes) for a short amount of time, as we'll set up a DMA from RAM to VRAM to happen later.
             // RAM: let's write the 9 tiles to $7E:1F5C..1F6E - top of stack (2 bytes per tile for this stage.)
             //      - we'll verify there's enough room in the stack first. i don't really care if it gets clobbered, it's just graphics. but let's be careful not to overwrite our own return address with gfx!
             // VRAM: then we'll queue a DMA from there to VRAM $580A..5813 (sub-section of the blank/unused top row, $5800-$5820)

             'tsx', /* tsx ie set X=S */
             0xe0, /* cpx compare X to imm */, [0x1F, 0x8E].reverse(), // $7E:1F6E end of the space we want + 0x20 bytes for function calls and interrupts = $7E:1F8E
             'bcs', /* branch-(if)-carry-set, branch if the result was positive or 0 */, 1, // if enough stack space, skip rts
             'rts', // if not enough stack space, return

             // write blank tiles to the initial tile data before we write digit tiles over some of this memory, so everything starts at a valid default
             'phy', // push Y register
             0xa9,  [0x2c, 0x0f].reverse(),       // LDA #$2c0f (blank tile type)
             0xa2,  [0x1f, 0x5c].reverse(),       // LDX #$1f5c (starting address of (misappropriated) top of stack area)
             0xa0,  [0x00, 0x12].reverse(),       // LDY #$0012 (0x12=0n18=2 bytes for each of the 9 2c0f's to write at $1f5c)
             'jsl', [0x80, 0x83, 0xf6].reverse(), // JSL $80:83F6 ; Write [Y] bytes of [A] to $7E:0000 + [X] - 16-bit
             'ply', // pull to Y register

             // create initial tile data at $7E:1F5C..1F6E
             // the callees can only write to addresses higher than $C608 (yeah, i tried wrapping the bank, it went into bank $7f instead) sigh. so:
             // (1) backup tiles to $88..8e (temp storage, part of dp (direct page instruction-accessible) RAM <= 0xff)
             // (2) overwrite tiles with calc
             // (3) move calc'ed tiles to $7e:1F5C..1F6E
             // ... repeat (2) and (3) for supers and pb's
             // (4) put backup back

             // (1):
             0xaf, [0x7e, 0xc6, 0x48].reverse(), // LDA $7e:c648. incidentally this is the 1st e tank
             0x8d, [0x00, 0x88].reverse(),       // STA $88
             0xaf, [0x7e, 0xc6, 0x4a].reverse(), // LDA $7e:c64a
             0x8d, [0x00, 0x8a].reverse(),       // STA $8a
             0xaf, [0x7e, 0xc6, 0x4c].reverse(), // LDA $7e:c64c
             0x8d, [0x00, 0x8c].reverse(),       // STA $8c

             // (2) & (3), repeated for each ammo type:
                                                  //               ; Missiles
             0xad, [0x09, 0xc8].reverse(),        //  LDA $09C8    ;\
             'beq', 28,                           //  BEQ 0n28       ;>, If [Samus max missiles] != 0:
             0xa2, [0x00, 0x40].reverse(),        //  LDX #$0040   ; X = missile count HUD tilemap destination offset
             'jsl', [0x80, 0x9c, 0xac].reverse(), //  JSL $80:9CAC ; Draw three HUD digits

             0xaf, [0x7e, 0xc6, 0x48].reverse(), // LDA $7e:c648
             0x8d, [0x1f, 0x5c].reverse(),       // STA $1f5c
             0xaf, [0x7e, 0xc6, 0x4a].reverse(), // LDA $7e:c64a
             0x8d, [0x1f, 0x5e].reverse(),       // STA $1f5e
             0xaf, [0x7e, 0xc6, 0x4c].reverse(), // LDA $7e:c64c
             0x8d, [0x1f, 0x60].reverse(),       // STA $1f60

                                                  //               ; Supers
             0xad, [0x09, 0xcc].reverse(),        //  LDA $09CC    ;\
             'beq', 21,                           //  BEQ 0n21       ;>, If [Samus max super missiles] != 0:
             0xa2, [0x00, 0x40].reverse(),        //  LDX #$0040   ; X = super missile count HUD tilemap destination offset
             'jsl', [0x80, 0x9c, 0xb0].reverse(), //  JSL $80:9CB0 ; Draw two HUD digits

             0xaf, [0x7e, 0xc6, 0x48].reverse(), // LDA $7e:c648
             0x8d, [0x1f, 0x64].reverse(),       // STA $1f64
             0xaf, [0x7e, 0xc6, 0x4a].reverse(), // LDA $7e:c64a
             0x8d, [0x1f, 0x66].reverse(),       // STA $1f66

                                                  //               ; Power Bombs
             0xad, [0x09, 0xd0].reverse(),        //  LDA $09D0    ;\
             'beq', 21,                           //  BEQ 0n21       ;>, If [Samus max power bombs] != 0:
             0xa2, [0x00, 0x40].reverse(),        //  LDX #$0040   ; X = power bomb count HUD tilemap destination offset
             'jsl', [0x80, 0x9c, 0xb0].reverse(), //  JSL $80:9CB0 ; Draw two HUD digits

             0xaf, [0x7e, 0xc6, 0x48].reverse(), // LDA $7e:c648
             0x8d, [0x1f, 0x6a].reverse(),       // STA $1f6a
             0xaf, [0x7e, 0xc6, 0x4a].reverse(), // LDA $7e:c64a
             0x8d, [0x1f, 0x6c].reverse(),       // STA $1f6c

             // (4) put backup back
             0xad, [0x00, 0x88].reverse(),       // LDA $88
             0x8f, [0x7e, 0xc6, 0x48].reverse(), // STA $7e:c648
             0xad, [0x00, 0x8a].reverse(),       // LDA $8a
             0x8f, [0x7e, 0xc6, 0x4a].reverse(), // STA $7e:c64a
             0xad, [0x00, 0x8c].reverse(),       // LDA $8c
             0x8f, [0x7e, 0xc6, 0x4c].reverse(), // STA $7e:c64c

             // finish up by queuing the DMA!
             0x20 /* jsr */, [0xd4, 0xf8].reverse(), // call $80:d4f8
             'rts', // return
             ].flat()},
    {address: 0x054f8, type: 'freespace',
     bytes: [
             // new code at $80:d4f8:
             //     queue DMA of 9*2 bytes
             // this code was copied starting from $80:9CAA with modified values
             0xAE, [0x03, 0x30].reverse(), // LDX $0330  [$7E:0330]  ;\
             0xA9, [0x00, 0x12].reverse(), // LDA #$0012             ;| // length in source (18 bytes)
             0x95, 0xD0,                   // STA $D0,x  [$7E:00D0]  ;|
             'inx',                        // INX                    ;|
             'inx',                        // INX                    ;|
             0xA9, [0x1F, 0x5C].reverse(), // LDA #$1F5C             ;|
             0x95, 0xD0,                   // STA $D0,x  [$7E:00D2]  ;|
             'inx',                        // INX                    ;|
             'inx',                        // INX                    ;> Queue transfer of $7E:1F5C..6E to VRAM $580A..5813 (part of top row of HUD tilemap)
             0xA9, [0x00, 0x7E].reverse(), // LDA #$007E             ;|
             0x95, 0xD0,                   // STA $D0,x  [$7E:00D4]  ;|
             'inx',                        // INX                    ;|
             0xA9, [0x58, 0x0A].reverse(), // LDA #$580A             ;|
             0x95, 0xD0,                   // STA $D0,x  [$7E:00D5]  ;|
             'inx',                        // INX                    ;|
             'inx',                        // INX                    ;|
             0x8E, [0x03, 0x30].reverse(), // STX $0330  [$7E:0330]  ;/

             'rts', // return

             ].flat()},
    {address: 0x05528, type: 'freespace',
     bytes: [
             // new code at $80:d528:
             //     check for cleanup needed & perform cleanup if so (normally would call this when equipment screen has faded to black)
             0xad /* lda */, [0x1f, 0x62].reverse(), // LDA $1f62
             0xc9 /* cmp imm */, [0x2c, 0x0f].reverse(), // is our blank tile chilling here at the (misappropriated) top of the stack area?
             'beq', 1, // branch-if-equal: skip rts if blank found (equal)
             'rts', // return if blank tile's tile number wasn't what was there

             0xad /* lda */, [0x1f, 0x68].reverse(), // LDA $1f68 (lower expected blank in stack, this one is between super and pb max ammo)
             0xc9 /* cmp imm */, [0x2c, 0x0f].reverse(), // is our blank tile chilling here at the (misappropriated) top of the stack area?
             'beq', 1, // branch-if-equal: skip rts if blank found (equal)
             'rts', // return if blank tile tile number wasn't what was there

             // still, we want to bail and not repeat a DMA if this routine already ran and blanked and DMA'ed everything
             // to do this, we bail if no digits are detected in the (misappropriated) top of the stack area
             //0xad /* lda */, [0x1f, 0x60].reverse(), // LDA $1f60 - lowest digit of max missile count in the (misappropriated) top of the stack area
             //0xc9 /* cmp */, [0x2c, 0x00].reverse(), // [$1f60] < #$2c00 ? skip to checking super count
             //0x90 /* bcc - branch if carry clear ie if ([$1f60] - #$2c00) was negative */, 5,
             //0xc9 /* cmp */, [0x2c, 0x0a].reverse(), // [$1f60] < #$2c0a ? then we have a digit! -> perform cleanup
             //0x90 /* bcc - branch if carry clear ie if ([$1f60] - #$2c0a) was negative */, 27,

             //0xad /* lda */, [0x1f, 0x66].reverse(), // LDA $1f66 - lowest digit of max super count in the (misappropriated) top of the stack area
             //0xc9 /* cmp */, [0x2c, 0x00].reverse(), // [$1f66] < #$2c00 ? skip to checking pb count
             //0x90 /* bcc - branch if carry clear ie if ([$1f66] - #$2c00) was negative */, 5,
             //0xc9 /* cmp */, [0x2c, 0x0a].reverse(), // [$1f66] < #$2c0a ? then we have a digit! -> perform cleanup
             //0x90 /* bcc - branch if carry clear ie if ([$1f66] - #$2c0a) was negative */, 14,

             //0xad /* lda */, [0x1f, 0x6c].reverse(), // LDA $1f6c - lowest digit of max pb count in the (misappropriated) top of the stack area
             //0xc9 /* cmp */, [0x2c, 0x00].reverse(), // [$1f6c] < #$2c00 ? skip to checking pb count
             //0x90 /* bcc - branch if carry clear ie if ([$1f6c] - #$2c00) was negative */, 5,
             //0xc9 /* cmp */, [0x2c, 0x0a].reverse(), // [$1f6c] < #$2c0a ? then we have a digit! -> perform cleanup
             //0x90 /* bcc - branch if carry clear ie if ([$1f6c] - #$2c0a) was negative */, 1,

             //0x60 /* rts */, // return because we didn't find the remnants of an intermediate copy of an actual digit 0-9

             // put blanks over the intermediate copy of each max ammo count tile (like memset)
             'phy', // push Y register
             0xa9, [0x2c, 0x0f].reverse(),       // LDA #$2c0f (blank tile type)
             0xa2, [0x1f, 0x5c].reverse(),       // LDX #$1f5c (starting address of (misappropriated) top of stack area)
             0xa0, [0x00, 0x12].reverse(),       // LDY #$0012 (0x12=0n18=2 bytes for each of the 9 2c0f's to write at $1f5c)
             'jsl', [0x80, 0x83, 0xf6].reverse(), // JSL $80:83F6 ; Write [Y] bytes of [A] to $7E:0000 + [X] - 16-bit
             'ply', // pull to Y register

             // queue DMA to copy said blanks back onto the real HUD in VRAM
             0x20 /* jsr */, [0xd4, 0xf8].reverse(), // call $80:d4f8
             'rts', // return

             ].flat()},
]

// suit pickup position, a softlock prevention by strotlog
// when she picks up gravity or varia suit, samus will now enter standing pose facing player as vanilla, but preserving the center of her X and Y position.
// this is instead of being placed in the center of the screen (for which the vanilla game calculates where to move samus in the room position based on current scroll values).
// still, kind of awkward because the expanding, full-screen graphical effect of samus powering up, a complex sequence of HDMA effects, is still centered in the middle of the
// screen and therefore not on samus.
suitPickupsNowPreserveSamusLocation = [
    // modify function "$91:D4E4: Varia suit pick up"
    // here we NOP out the vanilla writes (stores) to samus X pixel position, samus Y pixel position, samus previous X pixel position, samus previous Y pixel position
    {address: 0x8d57d, type: 'overwrite',
     bytes: ['nop', 'nop', 'nop', 'nop', 'nop', 'nop']},
    {address: 0x8d58a, type: 'overwrite',
     bytes: ['nop', 'nop', 'nop', 'nop', 'nop', 'nop']},
    // modify function "$91:D5BA: Gravity suit pick up"
    // same as previous above. we NOP out the vanilla writes (stores) to samus X pixel position, samus Y pixel position, samus previous X pixel position, samus previous Y pixel position
    {address: 0x8d655, type: 'overwrite',
     bytes: ['nop', 'nop', 'nop', 'nop', 'nop', 'nop']},
    {address: 0x8d662, type: 'overwrite',
     bytes: ['nop', 'nop', 'nop', 'nop', 'nop', 'nop']},
    // modify function $91:E258 where the second instruction queues item room music track (aka elevator music aka track 3).
    // NOP this instruction out. if we start item room music, it'd be too awkward if the next room loaded will have no track change (common) and keeps playing item room music.
    //   - how we get here: function "$91:D4E4: Varia suit pick up" -> uses HDMA object $91:D5A2, which -> references pre-instruction function $88:E026, which -> contains and calls function pointer to function $91:E258 as its last callee at the end of the animation/cleanup.
    //   - for some reason, this is not needed for gravity suit - at this point they differ only in that varia has this music instruction!
    {address: 0x4625b, type: 'overwrite',
     bytes: ['nop', 'nop', 'nop', 'nop']},
]

function awakeningPatch() {

    // this rom-reading is very unlikely to be necessary, but it's fun. cordon off into sub-function
    function getDoorAsmAddressToModify() {
        // all 3 real doors should be going to the rooms we think they are, and should have no door asm. just to be sure we're overwriting the right thing! this also makes us resilient to door repointing, and able to bail if rooms have been repointed
        // morph ball room's header (0x79e9f) in bank $8f:
        //     .(doors out arr pointer @ offset +9)
        // doors out arr in bank $8f:
        //     door 1 pointer - door to green hill zone (0x79e52) (points to door header for this door - door bank $83 is implied for door headers)
        //     door 2 pointer - door to construction zone (0x79f11)
        //     door 3 pointer - door to top of morph ball elevator room (0x797b5)
        //     fake door 4 pointer 88FC - means end of list - dereference and find offset 0 is 0000
        // door header in bank $83:
        //     .(dest room pointer, a room header @ offset 0)
        //     .(door asm pointer @ offset +0xa - bank $8f is implied for door asm code)
        requireddestinations = [{smileid: 0x79e52, roomname: 'Green Hill Zone'},
                                {smileid: 0x79f11, roomname: 'Construction Zone'},
                                {smileid: 0x797b5, roomname: 'Top of Morph Ball Elevator Room'},
                               ]
        destinationToModify = requireddestinations[1] // Construction Zone

        // read all 3 doors
        doorliststart = readUint16LE(loadedroms['rotation'].allbytes, 0x79e9f + 9)
        doorliststart |= 0x70000 // prepare to read again from bank $8f
        doors = [doorliststart, doorliststart+2, doorliststart+4].map(

            (doorlistentry) => readUint16LE(loadedroms['rotation'].allbytes, doorlistentry) | 0x10000 /* prepare to read from bank $83 */).map(

            (doorheader) => ({
                dest:    readUint16LE(loadedroms['rotation'].allbytes, doorheader),
                doorasm: readUint16LE(loadedroms['rotation'].allbytes, doorheader+0xa),
                thisDoorHeaderLocationInRom: doorheader,
            }))
        for (i = 0; i < requireddestinations.length; i++) {
            if (!(doors.map((door) => door.dest)).includes(requireddestinations[i].smileid & 0xffff)) {
                return { error: 'Error: Bailing, cannot confidently apply zebes awakening patch because ' + requireddestinations[i].roomname + ' not found in morph ball room\'s adjacent rooms in rotation rom. Doors found: ' + JSON.stringify(doors, stringifyInHex) }
            }
        }
        doorToModifyIndex = -1
        for (i = 0; i < doors.length; i++) {
            if (doors[i].dest === (destinationToModify.smileid & 0xffff)) {
                doorToModifyIndex = i
            }
            if (doors[i].doorasm !== 0) {
                if (doorToModifyIndex !== i) {
                    return { error: 'Error: At least one door in morph ball room in rotation rom, has door ASM already, cannot confidently apply zebes awakening patch. Doors found: ' + JSON.stringify(doors, stringifyInHex) }
                } else {
                    // well, this is the door we want to modify, which has an asm. report a similar error *tentatively*, but allow checking whether the desired patch was already applied
                    return { error: 'Error: The door we want to modify in morph ball room in rotation rom, has door ASM already. Cannot apply zebes awakening patch. Doors found: ' + JSON.stringify(doors, stringifyInHex),
                             checkAlreadyPatched: (doors[i].thisDoorHeaderLocationInRom + 0xa )
                            }
                }
            }
        }

        return { success: (doors[doorToModifyIndex].thisDoorHeaderLocationInRom + 0xa) }
    }

    doorfinder = getDoorAsmAddressToModify()
    if ('error' in doorfinder) {
        if (!('checkAlreadyPatched' in doorfinder)) {
            console.log(doorfinder['error'])
            return -1
        } else {
            doorAsmRomAddressToModify = doorfinder['checkAlreadyPatched'] // should be 0x18eb4
        }
    } else {
        doorAsmRomAddressToModify = doorfinder['success'] // should be 0x18eb4
    }

    zebesAwakeningPatch = [
                           // part 1: when samus enters construction zone from morph ball room, call (part 2)
                           {address: doorAsmRomAddressToModify, type: 'overwrite',
                            bytes: [0xff, 0x00].reverse()},
                           // part 2: ... set zebes awake event bit. (does not affect the currently loaded/loading room, but effective thereafter)
                           // part 2b: ... and also set the door from construction zone (vanilla-right; rotation-bottom) from red to blue
                           // new code at $8f:ff00:
                           {address: 0x7ff00, type: 'freespace',
                            bytes: [0xaf /* load  */, [0x7e, 0xd8, 0x20].reverse(),
                                    0x9 /* or */, [0x0, 0x1].reverse(), // set zebes awake event bit
                                    0x8f /* store */, [0x7e, 0xd8, 0x20].reverse(),
                                    0xaf /* load  */, [0x7e, 0xd8, 0xb6].reverse(),
                                    0x9, /* or */, [0x0, 0x4].reverse(), // set bit 4 (3rd bit) of 6th byte of the big door bitmask, ie this is the 51st (counting from 0: number 50 or 0x32) bit of doors. makes it blue
                                    0x8f /* store */, [0x7e, 0xd8, 0xb6].reverse(),
                                    0x60 /* rts return */,
                                    ].flat()},
                           // part 3: when checking the state of pit room or top of morph elevator room, read the zebes awake flag directly. forget about checking morph and missiles
                           //           (part 3 implementation choice: normally we'd just change the function pointer for the state-checking function, to point to the function that checks for a given event. done and done. but wait, that function requires 1 byte of space for a parameter (the "given event"), right after the function pointer, and meanwhile the vanilla morph+missile checking function requires no parameter. so inserting that 1 byte for a parameter would require repointing a ton of stuff! so we overwrite the morph+missile state-checking function's contents instead.)
                           // modify "$8F:E652: Room state check: morphball and missiles" from vanilla
                           {address: 0x7e652, type: 'overwrite',
                            bytes: [0xaf /* load  */, [0x7e, 0xd8, 0x20].reverse(),
                                    0x89 /* bit test A with constant */, [0x00, 0x01].reverse(),
                                    'bne', 3, // branch-(if)-not-equal-(to-zero): branch if a matching 1 bit was found
                                    // fall back to default state - room is dead
                                    'inx', // X++
                                    'inx', // X++ - fully passed over the pointer to 2nd (room alive) room state header, register X now pointing to next function pointer (E5E6: default state handler)
                                    'rts', // return
                                    // specify state header "room is alive"!
                                    0xbd /* load A=*(X+0) */, 0x00, 0x00,
                                    'tax', /* X=A */
                                    0x4c /* jmp */, [0xe5, 0xe6].reverse(),
                                    ].flat()},
                           // part 4: force the BT fight as soon as samus enters the room. (sm rotation always locks you in the room, beating bt unlocks the door.)
                           // modify "$84:D33B: wake PLM if Samus has bombs" from vanilla, which wakes bomb torizo (BT)
                           // random note, this patch is sufficient for rotation but wouldn't be for vanilla. rotation replaced the very custom door in the room with a generic gray door, which always closes.
                           {address: 0x2533b, type: 'freespace',
                            bytes: ['nop', 'nop', 'nop', // remove the "If Samus doesn't have bombs" branch
                                    'nop', 'nop', 'nop', // for the crumbling chozo,
                                    'nop', 'nop',        // using NOP x8
                                    ].flat()},
                           ]
    if ('checkAlreadyPatched' in doorfinder) {
        // allow us to process multiple rando roms in a single session!
        if (!(checkForPatch([zebesAwakeningPatch[0], zebesAwakeningPatch[1]]))) {
            // patch NOT found (at least not entirely), bail
            if ('error' in doorfinder) {
                console.log(doorfinder['error'])
            } else {
                console.log('checkAlreadyPatch requested and zebesAwakeningPatch [0] and/or [1] not detected in rotation rom')
            }
            return -1
        }
    }
    if (zebesAwakeningPatch[2].bytes.length > 19) {
        console.log('Implementation error: patching ROM function $8F:E652 has space for only 19 bytes, but the one in this javascript code is ' + zebesAwakeningPatch[2].bytes.length + ' bytes long which does not fit!')
        return -1
    }
    if (checkForOverlappingPatches(zebesAwakeningPatch)) {
        return -1
    }
    if (checkForFreespaceConflict(zebesAwakeningPatch)) {
        return -1
    }

    zebesAwakeningPatch = assembleUnambiguousInstructions(zebesAwakeningPatch)
    if (zebesAwakeningPatch.length === 0) {
        return -1
    }
    applyPatch(zebesAwakeningPatch)
    return 0
}

loadedroms = {}

function addRomFiles(purpose, filesarr) {
    if (filesarr.length === 0) {
        return
    }
    if (filesarr.length > 1) {
        console.log('Received ' + filesarr.length + ' files at once, ignoring (expected 1)')
        return
    }
    let fr = new FileReader()
    // ".onload" is basically the ".then" of readAsArrayBuffer() which we're about to call
    fr.onload = function(event) {
        loadedroms[purpose] = {
            filename: filesarr[0].name,
            allbytes: new Uint8Array(event.target.result),
        }
        updateState()
    }
    fr.readAsArrayBuffer(filesarr[0])
}

function updateState() {
    if ('rotation' in loadedroms) {
        document.getElementById('spanIdRotationRomFilename').textContent = loadedroms['rotation'].filename
    }
    if ('rando' in loadedroms) {
        document.getElementById('spanIdRandoRomFilename').textContent = loadedroms['rando'].filename
    }
    if ('rotation' in loadedroms && 'rando' in loadedroms) {
        document.getElementById('aIdDownloadLink').textContent = '' // remove link (if any previous one was shown)
        if (loadedroms['rotation'].allbytes.length < 2*1024*1024) {
            console.log('Rotation ROM provided is only ' + loadedroms['rotation'].allbytes.length + ' bytes, expected over ' + 3*1024*1024)
            return
        }
        if (loadedroms['rando'].allbytes.length < 2*1024*1024) {
            console.log('Rando ROM provided is only ' + loadedroms['rando'].allbytes.length + ' bytes, expected ' + 3*1024*1024 + ' or more')
            return
        }
        ret = patchmain()
        if (ret != 0) { return }

        let blob = new Blob([loadedroms['rotation'].allbytes], {type: 'application/octet-stream'})
        document.getElementById('aIdDownloadLink').href = URL.createObjectURL(blob)
        document.getElementById('aIdDownloadLink').download = 'SM Rotation with items copied from ' + loadedroms['rando'].filename
        document.getElementById('aIdDownloadLink').textContent = 'Download Modified SM: Rotation'
    }
}

</script>
    </head>

<body ondrop="event.preventDefault()"
      ondragover="event.preventDefault()">
    <p>Rando&times;Rotation: Welcome to a very basic Web tool that shuffles the items in <strong><a href="https://metroidconstruction.com/hack.php?id=350">Super Metroid: Rotation</a></strong> (Beta 11).</p>
    <p>This is not exactly a randomizer. Instead, it copies the locations of all the items from a <strong><a href="https://varia.run/">VARIA Randomizer</a></strong> ROM seed that you provide. (VARIA itself may include a rotation randomizer soon.)</p>
    <p>This:</p>
    <ul>
        <li>Applies <dfn title="1. TBD; 2. vanilla bug patch(es); 3. can always reach Taco tank room & BT's door, & fight BT; 4. balanced suits; 5. escape-climb softlock fix; 6. max ammo equip screen; 7. suit pickup stands samus in-place" style="font-style: normal; text-decoration: underline; text-decoration-style: dotted">some minimal</dfn> code patches (the list may grow later). Beyond these changes, it is exactly like SM: Rotation except the items are moved. Be careful and save!</li>
        <li><strong>Does not ensure the seed is completable.</strong></li>
        <li>Will not show errors plainly yet - check your browser's console if a download link doesn't appear.</li>
        <li>Will not upload or store anything - it's all in your browser. (This means links generated are very temporary and local to this tab.)</li>
    </ul>
    <p>by strotlog 2022</p>
    <div id='divIdRandoRomArea' style='border: 1px; border-style: dotted' ondrop="event.preventDefault(); addRomFiles('rando', event.dataTransfer.files)">
        <h3>Rando ROM</h3>
        <input type='file' id='inputIdRandoRom' style='display:none' onchange="addRomFiles('rando', this.files)"/>
        <input type='button' id='inputIdRandoRomButton' value='Browse' onclick="document.getElementById('inputIdRandoRom').click()"/>
        <span id='spanIdRandoRomFilename'>(No file)</span>
    </div>
    <div id='divIdRotationRomArea' style='border: 1px; border-style: dotted' ondrop="event.preventDefault(); addRomFiles('rotation', event.dataTransfer.files)">
        <h3>Vanilla Rotation ROM</h3>
        <input type='file' id='inputIdRotationRom' style='display:none' onchange="addRomFiles('rotation', this.files)"/>
        <input type='button' id='inputIdRotationRomButton' value='Browse' onclick="document.getElementById('inputIdRotationRom').click()"/>
        <span id='spanIdRotationRomFilename'>(No file)</span>
    </div>
    <div>
        <h3>
            <a href='#' download='' id='aIdDownloadLink'></a>
        </h3>
    </div>
</body>
</html>
