<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Romhack a SM rando</title>
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://strotlog.github.io/romhackizer/">
        <meta property="og:title" content="Romhackizer">
        <meta property="og:description" content="Copy the 100 item locations from a Super Metroid randomizer seed, into a romhack of SM">
        <link rel="icon" type="image/png" href="favicon.ico">
        <!--<meta property="og:image" content="">-->

<script>

// utilities
function stringifyInHex(key, value) {
    if (typeof value === 'number') {
        return '0x' + value.toString(16)
    } else {
        return value
    }
}
function readUint16LE(bytearr, address) {
    return bytearr[address] + 256*bytearr[address+1]
}
function applyPatch(modifications) {
    modifications.forEach((modification) => {
        if (modification.hasOwnProperty('description')) { // 1st modif in a bunch usually has a description
            console.log('applying js patch: ' + modification.description)
        }
        for (i = 0; i < modification.bytes.length; i++) {
            loadedroms['romhack'].allbytes[modification.address + i] = modification.bytes[i]
        }
    })
}
function checkForPatch(modifications) {
    rets = modifications.map((modification) => {
        for (i = 0; i < modification.bytes.length; i++) {
            if (loadedroms['romhack'].allbytes[modification.address + i] !== modification.bytes[i]) {
                return false
            }
        }
        return true // this modification found
    })
    if (rets.includes(false)) {
        return false
    }
    return true // all modifications found
}
function checkForFreespaceConflict(modifications) {
    rets = modifications.map((modification) => {
        if (modification.type !== 'freespace') {
            return false
        }
        for (i = modification.address; i < modification.bytes.length; i++) {
            if (loadedroms['romhack'].allbytes[i] !== 0xff) {
                // current copy of the rotation rom has code where freespace was expected
                if (checkForPatch([modification])) {
                    // no problem, the rotation rom already has exactly this patch
                    // (as is the case when we rpocess multiple seeds in one session
                    return false
                } else {
                    // not 0xff and not the exact same patch => a conflict
                    console.log('patch beginning at 0x' + modification.address.toString(16) + ' length 0n' + modification.allbytes.length + ' which is intended for free space, conflicts with data found in the rotation rom')
                    return true
                }
            }
        }
        return false
    })
    if (rets.includes(true)) {
        return true
    }
    return false // all modifications had no conflict
}
function checkForOverlappingPatches(modifications) {
    // turn each patch into 2 markers: one for where it begins, one for where it ends. then sort all the markers together and check for double-begins
    ordered = modifications.map((modification) => [{address: modification.address, type: 'begin' },
                                                   {address: modification.address + modification.bytes.length, type: 'end'}]
                                ).flat().sort((a, b) => {
                                    if (a.address < b.address) { return -1 }
                                    if (a.address > b.address) { return 1 }
                                    // consider 'end' as less than 'begin', because if one patch ends where another begins that's ok ('end' points to the first byte not modified by a given patch)
                                    if (a.type === 'end'   && b.type === 'begin') { return -1 }
                                    if (a.type === 'begin' && b.type === 'end'  ) { return 1 }
                                    return 0
                                })
    begunpatches = 0
    for (i = 0; i < ordered.length; i++) {
        if (ordered[i].type === 'begin') {
            begunpatches++
        } else {
            begunpatches--
        }
        if (begunpatches > 1) {
            console.log('patch beginning at 0x' + ordered[i].address.toString(16) + ' overlaps with an earlier patch! all patches examined: ' + JSON.stringify(modifications, stringifyInHex))
            return true // overlap!
        }
    }
    return false
}
function assembleUnambiguousInstructions(modifications) {
    ret = modifications.map(function (modification) {
        modification.bytes = modification.bytes.map(function (byteOrOpcode) {
            if (typeof byteOrOpcode !== 'string') {
                return byteOrOpcode
            }
            if (byteOrOpcode.toUpperCase() in unambiguousInstructionMapping) {
                return unambiguousInstructionMapping[byteOrOpcode.toUpperCase()]
            }
            console.log('patch beginning at 0x' + modification.address.toString(16) + ' contains the opcode \'' + byteOrOpcode + '\', which does not exist OR is ambiguous (context-dependent opcodes like LDA are not supported yet)')
            return 'error'
        });
        if (modification.bytes.includes('error')) {
            return 'error'
        }
        return modification
    });
    if (ret.includes('error')) {
        return []
    }
    return ret
}
unambiguousInstructionMapping = {
'INY': 0xC8, 'INX': 0xE8, 'DEY': 0x88, 'DEX': 0xCA, 'BPL': 0x10, 'BMI': 0x30, 'BVC': 0x50, 'BVS': 0x70,
'BRA': 0x80, 'BRL': 0x82, 'BCC': 0x90, 'BCS': 0xB0, 'BNE': 0xD0, 'BEQ': 0xF0, 'JSL': 0x22, 'RTS': 0x60,
'RTL': 0x6B, 'CLC': 0x18, 'SEC': 0x38, 'CLI': 0x58, 'SEI': 0x78, 'CLV': 0xB8, 'CLD': 0xD8, 'SED': 0xF8,
'TCS': 0x1B, 'TSC': 0x3B, 'TCD': 0x5B, 'TDC': 0x7B, 'TXA': 0x8A, 'TYA': 0x98, 'TXS': 0x9A, 'TXY': 0x9B,
'TAY': 0xA8, 'TAX': 0xAA, 'TSX': 0xBA, 'TYX': 0xBB, 'MVP': 0x44, 'MVN': 0x54, 'PER': 0x62, 'PEI': 0xD4,
'PEA': 0xF4, 'PHP': 0x08, 'PHD': 0x0B, 'PHA': 0x48, 'PHK': 0x4B, 'PHY': 0x5A, 'PHB': 0x8B, 'PHX': 0xDA,
'PLP': 0x28, 'PLD': 0x2B, 'PLA': 0x68, 'PLY': 0x7A, 'PLB': 0xAB, 'PLX': 0xFA, 'NOP': 0xEA, 'REP': 0xC2,
'SEP': 0xE2, 'XBA': 0xEB, 'XCE': 0xFB, 'BRK': 0x00, 'COP': 0x02, 'RTI': 0x40, 'WAI': 0xCB, 'STP': 0xDB,
}
function snesAddrStringFromRomOffset(romoffset) {
    within = romoffset % 0x8000
    bank = (romoffset - within) / 0x8000 + 0x80
    return bank.toString(16) + ":" + (within + 0x8000).toString(16)
}
function romOffsetFromSnesAddrString(snesAddrString) {
    if (snesAddrString[0] == "$") {
        snesAddrString = snesAddrString.substring(1)
    }
    [bank, highwithin] = snesAddrString.split(":")
    bank = parseInt("0x" + bank)
    highwithin = parseInt("0x" + highwithin)
    return (bank - 0x80)*0x8000 + (highwithin - 0x8000)
}


loadedroms = {}

function addRomFiles(purpose, filesarr) {

    if (filesarr.length === 0) {
        return
    }
    if (filesarr.length > 1) {
        console.log('Received ' + filesarr.length + ' files at once, ignoring (expected 1)')
        return
    }
    let fr = new FileReader()
    // ".onload" is basically the ".then" of readAsArrayBuffer() which we're about to call
    fr.onload = function(event) {
        loadedroms[purpose] = {
            filename: filesarr[0].name,
            allbytes: new Uint8Array(event.target.result),
        }
        updateState()
    }
    fr.readAsArrayBuffer(filesarr[0])
}

let g_completed = false

function updateState() {
    if ('rando' in loadedroms) {
        document.getElementById('spanIdRandoRomFilename').textContent = loadedroms['rando'].filename
    }
    if ('vanilla' in loadedroms) {
        document.getElementById('spanIdVanillaRomFilename').textContent = loadedroms['vanilla'].filename
    }
    if ('romhackIps' in loadedroms) {
        document.getElementById('spanIdRomhackIpsFilename').textContent = loadedroms['romhackIps'].filename
    }
    if ('rando' in loadedroms && 'vanilla' in loadedroms && 'romhackIps' in loadedroms) {
        document.getElementById('aIdDownloadLink').textContent = '' // remove link (if any previous one was shown)
        // determine romhack. a checksum would be nice, but length works in a pinch
        let hackname
        if (loadedroms['romhackIps'].allbytes.length == 917097) {
            hackname = 'zfactor'
        } else if (loadedroms['romhackIps'].allbytes.length == 550480) {
            hackname = 'rotation'
        } else {
            console.log('Unexpected IPS length: ' + loadedroms['romhackIps'].allbytes.length + ' bytes. Expected 917097 (zfactor) or 550480 (rotation)')
            return
        }
        console.log('Detected hack \'' + hackname + '\' based on ips')
        if (loadedroms['vanilla'].allbytes.length < 2*1024*1024) {
            console.log('Vanilla SM ROM provided is only ' + loadedroms['vanilla'].allbytes.length + ' bytes, expected ' + 3*1024*1024 + ' (3MB)')
            return
        }
        if (loadedroms['rando'].filename.endsWith('.apsm')) {
            if (g_completed) {
                console.log('Please reload the page before doing Archipelago') // because we need that rotation data to be pristine to read the bsdiff correctly
                return
            }
            g_completed = true
            ret = archipelagoRidiculum(hackname)
        } else {
            if (loadedroms['rando'].allbytes.length < 2*1024*1024) {
                console.log('Rando ROM provided is only ' + loadedroms['rando'].allbytes.length + ' bytes, expected ' + 3*1024*1024 + ' or more')
                return
            }
            // do original functionality: move items from rando rom to romhack and patch the romhack
            // first we have to create an in-browser-memory copy of the romhack rom
            let romhackSize
            if (hackname == 'rotation') {
                romhackSize = 3*1024*1024 + 2*0x8000
            } else if (hackname == 'zfactor') {
                romhackSize = 3*1024*1024 + 5*0x8000
            }
            loadedroms['romhack'] = {filename: 'Super Metroid ' + hackname + '.sfc', // not really used
                                     allbytes: new Uint8Array(romhackSize),
                                     }
            for (let i = 0; i < loadedroms['vanilla'].allbytes.length; i++) {
                // copy vanilla to a new ROM
                loadedroms['romhack'].allbytes[i] = loadedroms['vanilla'].allbytes[i]
            }
            for (let i = 3*1024*1024; i < loadedroms['romhack'].allbytes.length; i++) {
                // extend ROM to correct romhack size
                loadedroms['romhack'].allbytes[i] = 0xff
            }
            // create romhack
            romhackmod = readips(loadedroms['romhackIps'].allbytes)
            if (romhackmod.length == 0) { // invalid ips
                return
            }
            applyPatch(romhackmod)

            // everything looks good, do main functionality
            g_completed = true
            if (hackname == 'rotation') {
                patches = romhacks.rotation.patchmain({hasRoms: true, loadedroms: loadedroms})
                if (checkForOverlappingPatches(patches)) {
                    return
                }
                if (checkForFreespaceConflict(patches)) {
                    return
                }
                patches = assembleUnambiguousInstructions(patches)
                if (patches.length === 0) {
                    return
                }

                applyPatch(patches)
            } else if (hackname == 'zfactor') {
            }
            let prettyHackname = hackname[0].toUpperCase() + hackname.slice(1)
            updateDownload('SM ' + prettyHackname + ' with items copied from ' + loadedroms['rando'].filename,
                           loadedroms['romhack'].allbytes,
                           'Download Modified SM: ' + prettyHackname)
        }
    }
}

function updateDownload(filename, bytes, linktext) {
    let blob = new Blob([bytes], {type: 'application/octet-stream'})
    document.getElementById('aIdDownloadLink').href = URL.createObjectURL(blob)
    document.getElementById('aIdDownloadLink').download = filename
    document.getElementById('aIdDownloadLink').textContent = linktext
}

function archipelagoRidiculum(hackname) {

    loadedroms['apsm'] = loadedroms['rando'] // not really a ROM in any case

    requirejs.config({
        appDir: ".",
        baseUrl: '.',
        paths: {
            'compressjs' : ["https://cdn.jsdelivr.net/npm/compressjs@1.0.3"],
            'js-yaml'    : ["https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist"],
        },
    });
    requirejs(['compressjs/main.min' /* requirejs will expands 'compressjs' before slash to become the URL directory we specified in 'paths', and will append '.js' to the end */,
               'js-yaml/js-yaml.min',
               'archipelago' /* ie, ./archipelago.js which must be written in a requirejs module-y way */,
               ], function(compressjs, jsyaml, archipelago) {
        console.log('loaded requirements')
        cjs = compressjs
        jsy = jsyaml
        archi = archipelago
        fetch("https://raw.githubusercontent.com/strotlog/SMBasepatch/zfactor/build/romhacks/" + hackname + "/multiworld-basepatch.ips").then(
            (response) => response.blob()).then(
            (basepatch_blob) => basepatch_blob.arrayBuffer()).then(function (basepatch_arraybuffer) {
                console.log('fetched ips')
                let basepatch_ips = new Uint8Array(basepatch_arraybuffer)
                let basepatch = readips(basepatch_ips)
                if (basepatch.length == 0) {
                    console.log('failed to process basepatch')
                    return -1
                }
                let localpatches = []
                if (hackname == 'rotation') {
                    localpatches = romhacks.rotation.patchmain({hasRoms: false})

                    if (checkForOverlappingPatches(localpatches)) {
                        return -1
                    }
                    localpatches = assembleUnambiguousInstructions(localpatches)
                    if (localpatches.length === 0) {
                        return -1
                    }
                } else if (hackname == 'zfactor') {
                }

                // see if basepatch overlaps with our local patches that are specific to randoing this romhack
                let combinedpatches = []
                combinedpatches.push(...basepatch)
                combinedpatches.push(...localpatches) // pretty much all the patches aside from the bsdiff itself
                if (checkForOverlappingPatches(combinedpatches)) {
                    return -1
                }
                let romhackmod = readips(loadedroms['romhackIps'].allbytes)
                if (romhackmod.length == 0) {
                    console.log('failed to process romhack ips')
                    return -1
                }
                // patch order is:
                //     1) start a fresh bsdiff patch based on vanilla
                //    we specify the order of these three right here:
                //    {
                //     2) add romhack (now it's the romhack)
                //     3) add AP basepatch tailored to the addresses available in this specific romhack
                //     4) add localpatches
                //    }
                //     5) copy items from apsm
                //     6) copy seed-specific data from apsm over top of some of the AP basepatch
                let finished_apsm = archi.archipelagomagic(loadedroms['apsm'].allbytes,
                                                           [romhackmod, basepatch, localpatches], /* order of patching is important! */
                                                           loadedroms['vanilla'].allbytes,
                                                           romhacks.offsetsInRomOf100ItemPlms,
                                                           hackname)
                let arraybuffer = new ArrayBuffer(finished_apsm.buffer, finished_apsm.byteOffset, finished_apsm.byteLength)
                updateDownload('Rotated ' + loadedroms['apsm'].filename,
                               finished_apsm,
                               'Download Rotated AP Multiworld World (beta)')

            }) //.catch(error => console.log(error)) // better to have the debugger catch it
    })


    return 0
}

function readips(binary) {
    let ret = []
    let i = 5
    while (i < binary.length-3) {
        let address = binary[i] * 65536 + binary[i+1] * 256 + binary[i+2]
        let length = binary[i+3] * 256 + binary[i+4]
        if (length == 0) {
            let rlelength = binary[i+5] * 256 + binary[i+6]
            let rlebyte = binary[i+7]
            let bytearr = new Uint8Array(rlelength)
            for (j = 0; j < rlelength; j++) {
                bytearr[j] = rlebyte
            }
            ret.push({address: address, type: 'overwrite',
                      bytes: bytearr})
            i += 8
        } else {
            ret.push({address: address, type: 'overwrite',
                      bytes: binary.slice(i+5, i+5+length)})
            i += 5 + length
        }
    }
    if (i != binary.length - 3) {
        console.log('ips failed to parse! i=' + i + ', length=' + binary.length)
        return []
    }
    return ret
}

document.addEventListener('DOMContentLoaded', function (event) {
    // check upon loading, before we have any ROMs, for a query string
    httpQuery = new URLSearchParams(window.location.search)
    // support simply exporting an IPS of our current patches at ?getips. note, after someone applies this IPS, the ROM will still have to be loaded with rando items
    if (httpQuery.has('getips') || httpQuery.has('getRotationIps')) {
        let patches = romhacks.rotation.patchmain({hasRoms: false})

        if (checkForOverlappingPatches(patches)) {
            return -1
        }
        patches = assembleUnambiguousInstructions(patches)
        if (patches.length === 0) {
            return -1
        }
    
        ipsbytes = []
        ipsbytes.push(...Array.from('PATCH').map((c) => c.charCodeAt(0)))
        for (modification of patches) {
            // address: 24-bit big endian
            ipsbytes.push(...[(modification.address & 0xff0000) >> 16,
                              (modification.address & 0x00ff00) >> 8,
                              (modification.address & 0x0000ff)])
            // length: 16-bit big endian
            ipsbytes.push(...[(modification.bytes.length & 0xff00) >> 8,
                              (modification.bytes.length & 0x00ff)])
            // bytes
            ipsbytes.push(...modification.bytes)
        }
        ipsbytes.push(...Array.from('EOF').map((c) => c.charCodeAt(0)))
    
        ipsbytearray = new Uint8Array(ipsbytes)
        console.log(ipsbytearray[0])
        blob = new Blob([ipsbytearray], {type: 'application/octet-stream'})
        document.getElementById('aIdDownloadLink').href = URL.createObjectURL(blob)
        document.getElementById('aIdDownloadLink').download = 'randoxrotation-patches' + (new Date()).toISOString().split('T')[0] + '.ips'
        document.getElementById('aIdDownloadLink').textContent = 'Download patch IPS (no items)'
    }
})

</script>
    </head>

<body ondrop="event.preventDefault()"
      ondragover="event.preventDefault()">
    <p>Rando&times;Rotation: Welcome to a very basic Web tool that shuffles the items in <strong><a href="https://metroidconstruction.com/hack.php?id=350">Super Metroid: Rotation</a></strong> (Beta 11).</p>
    <p>This is not exactly a randomizer. Instead, it copies the locations of all the items from a <strong><a href="https://varia.run/">VARIA Randomizer</a></strong> ROM seed that you provide. (VARIA itself may include a rotation randomizer soon.)</p>
    <p>This:</p>
    <ul>
        <li>Applies <dfn title="1. TBD; 2. vanilla bug patch(es); 3. can always reach Taco tank room & BT's door; 4. BT wakes; 5. balanced suits; 6. screw attack menuing; 7. speed echoes in heated room; 8. spring change in bounce crash fix; 9. escape-climb softlock fix; 10. down-facing gadora crash fix; 11. max ammo equip screen; 12. suit pickup restores position; 13. faster intro" style="font-style: normal; text-decoration: underline; text-decoration-style: dotted">some minimal</dfn> code patches (the list may grow later). Beyond these changes, it is exactly like SM: Rotation except the items are moved. Be careful and save!</li>
        <li><strong>Does not ensure the seed is completable.</strong></li>
        <li>Will not show errors plainly yet - check your browser's console if a download link doesn't appear.</li>
        <li>Will not upload or store anything - it's all in your browser. (This means links generated are very temporary and local to this tab.)</li>
    </ul>
    <p>by strotlog 2022</p>
    <div id='divIdRandoRomArea' style='border: 1px; border-style: dotted' ondrop="event.preventDefault(); addRomFiles('rando', event.dataTransfer.files)">
        <p><h3 style="display: inline">
            Rando ROM
        </h3><div style="color:#666666">&nbsp;or Archipelago .apsm (beta)</div></p>
        <input type='file' id='inputIdRandoRom' style='display:none' onchange="addRomFiles('rando', this.files)" accept=".sfc,.smc,.apsm" />
        <input type='button' id='inputIdRandoRomButton' value='Browse' onclick="document.getElementById('inputIdRandoRom').click()"/>
        <span id='spanIdRandoRomFilename'>(No file)</span>
    </div>
    <div id='divIdVanillaRomArea' style='border: 1px; border-style: dotted' ondrop="event.preventDefault(); addRomFiles('vanilla', event.dataTransfer.files)">
        <h3>
            Vanilla Super Metroid ROM (unheadered)
        </h3>
        <input type='file' id='inputIdVanillaRom' style='display:none' onchange="addRomFiles('vanilla', this.files)" accept=".sfc,.smc" />
        <input type='button' id='inputIdVanillaRomButton' value='Browse' onclick="document.getElementById('inputIdVanillaRom').click()"/>
        <span id='spanIdVanillaRomFilename'>(No file)</span>
    </div>
    <div id='romhackIpsArea' style='border: 1px; border-style: dotted' ondrop="event.preventDefault(); addRomFiles('romhackIps', event.dataTransfer.files)">
        <p><h3 style="display:inline">
            Rotation Hack IPS
        </h3><div style="color:#333333">&nbsp;by SMILEuser96</div></p>
        <input type='file' id='inputIdRomhackIps' style='display:none' onchange="addRomFiles('romhackIps', this.files)" accept=".ips" />
        <input type='button' id='inputIdRomhackIpsButton' value='Browse' onclick="document.getElementById('inputIdRomhackIps').click()"/>
        <span id='spanIdRomhackIpsFilename'>(No file)</span>
    </div>
    <div>
        <h3>
            <a href='#' download='' id='aIdDownloadLink'></a>
        </h3>
    </div>
</body>
<!-- include our scripts directly, except archipelago.js (which uses dependencies, see below) -->
<script src="generalpatches.js" ></script>
<script src="romfeatures.js" ></script>
<script src="romhacks.js" ></script>
<!-- requirejs is very, well, required, for the archipelago code path. global <script> js code does not run after this point! -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
</html>

